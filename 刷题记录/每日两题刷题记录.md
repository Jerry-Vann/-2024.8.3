

5.13日启动代码随想录新一轮刷题，每日两道，希望是不同类型的题目，例如一道数组、一道树

5.13

```c++
**数组2.二分查找**
易错注意点：left和right的更新，例如left=middle错误，left=middle+1正确。
原因是假设我们有一个数组 {1, 2, 3, 4, 5, 6}，并且我们要搜索的目标值是7。如果我们使用你最初的代码，它可能会导致死循环。
**链表2.移除链表元素**
易错注意点：
链表的定义要会写：
struct ListNode {
     int val;
     ListNode *next;
     ListNode() : val(0), next(nullptr) {}
     ListNode(int x) : val(x), next(nullptr) {}
     ListNode(int x, ListNode *next) : val(x), next(next) {}
 };
 还需要注意虚拟头结点的定义方式，ListNode* prehead =new ListNode(0);
```

5.14

```c++
**数组3.移除元素**
巧妙的交换元素法
    int removeElement(vector<int>& nums, int val) {
        int length = nums.size()-1;
        for(int i=0; i<=length; i++){
            if(nums[i] == val){
                swap(nums[i--], nums[length--]);
            }
        }
        return length+1;
    }
**链表3.设计链表**
熟悉链表操作的细节，并能手写出来
```

5.15

```markdown
**数组4.有序数组的平方**
双指针大法好
**链表4.翻转链表**
双指针大法，想要翻转一个链表，需要设置一个pre和一个cur，在循环内部在设置一个临时指针tmp=cur->next
```

5.16

```markdown
**数组5.长度最小的子数组**
滑动窗口的应用，外层循环的j当做窗口右端，内层来控制窗口左端
**链表5.两两交换链表中的结点**
设置一个虚拟头结点，循环中判断这个结点后面是否存在两个结点，相当于以被交换的两个结点的前一个结点为哨兵结点。
```

5.17

```markdown
**数组6.螺旋矩阵二**
```

<img src="C:\Users\93781\Desktop\c++runrunrun\刷题记录\数组6.螺旋矩阵二.jpg" alt="数组6.螺旋矩阵二" style="zoom: 67%;" />

```markdown
**链表6.删除链表的倒数第N个节点**
双指针，先right移动N步，再left和right一起移动
```



5.19

```markdown
**链表7.链表相交**
两个指针走同长度的路，来找到共同节点
**哈希表1.哈希表理论基础****哈希表2.有效的字母异位词**
方法一：分别用两个数组存储两个字符串各字母出现的次数
方法二：只用一个数组存储s字符串各字母出现次数，再减去t字符串各字母出现次数，最终比较各位是否为0
```

5.20

```markdown
**链表8.环形链表二**
那么相遇时： slow指针走过的节点数为: x + y， fast指针走过的节点数：x + y + n (y + z)，n为fast指针在环内走了n圈才遇到slow指针， （y+z）为 一圈内节点的个数A。

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

(x + y) * 2 = x + y + n (y + z)

两边消掉一个（x+y）: x + y = n (y + z)

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。

所以要求x ，将x单独放在左面：x = n (y + z) - y ,

再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：x = (n - 1) (y + z) + z 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。

这个公式说明什么呢？

先拿n为1的情况来举例，意味着fast指针在环形里转了一圈之后，就遇到了 slow指针了。

当 n为1的时候，公式就化解为 x = z，

这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。

也就是在相遇节点处，定义一个指针index1，在头结点处定一个指针index2。

让index1和index2同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。
```

![链表8.环形链表二](C:\Users\93781\Desktop\c++runrunrun\刷题记录\链表8.环形链表二.png)



```c++
**哈希表3.两个数组的交集**
对set的操作不熟悉，注意其中的操作
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;// 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());//注意操作
        for(int i=0; i<nums2.size(); i++){
            if(nums_set.find(nums2[i]) != nums_set.end()) result_set.insert(nums2[i]);
        }
        return vector<int>(result_set.begin(), result_set.end());//操作
    }
```



5.21

```markdown
**哈希表4.快乐数**
unordered_set 的使用
**字符串1.反转字符串**
双指针秒了
```



5.22

```c++
**哈希表5.两数之和**
注意map的使用方法
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map<int,int> map;
        for(int i=0; i<nums.size(); i++){
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]);
            if(iter != map.end())
                return {iter->second, i};
            map.insert(pair<int, int>(nums[i], i));
            // 也可以用map[nums[i]] = i;
        }
        return {};
    }
```



```c++
**字符串2.反转字符串二**
关键点：
1.reverse函数不处理第二个参数所在位置的字符
2.s.end() 返回的是一个迭代器，指向字符串 s 的最后一个字符的下一个位置。因此，s.end() - 1 指向的是字符串的最后一个字符

    string reverseStr(string s, int k) {
        for (int i = 0; i < s.size(); i += (2 * k)) {
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if (i + k <= s.size()) {
                reverse(s.begin() + i, s.begin() + i + k );
            } else {
                // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
                reverse(s.begin() + i, s.end());
            }
        }
        return s;
    }
```

5.23

```c++
**哈希表6.四数相加二**
关键在于两个数组分一组，时间复杂度最小化，以及用unordered_map，key值存放前两个数组两元素相加的和，value值记录这个和出现的次数。
细节操作点：基于范围的for循环的使用，以及map插入键和值。
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        std::unordered_map<int,int> map;
        for(int a:nums1){
            for(int b:nums2){
                map[a+b]++;
            }
        }
        int count = 0;
        for(int c:nums3){
            for(int d:nums4){
                if(map.find(0-c-d)!=map.end()) count+=map[0-c-d];
            }
        }
        return count;
    }
```



```c++
**字符串3.替换数字**
注意点1.作为string类型，a.push_back()只能对单个字符操作，所以以下代码需要逐一将 n 中的字符添加到 a 中。
注意点2.一开始rever我写的第二个参数是const string n，这是传值方法，意味着在函数内部拥有了参数 n 的一个副本。这意味着系统需要为这个副本分配内存空间，并将参数 n 的值复制到这个新分配的内存空间中。这样的话，如果参数 n 是一个比较大的字符串，这个复制操作会造成一定的性能开销。
void rever(string &S, const string& n){
    string a;
    for(char s : S){
        if(s - '0' >= 0 && s - '0' <= 9) // 检查字符是否是数字
            for(char c : n) // 逐一将 n 中的字符添加到 a 中
                a.push_back(c);
        else
            a.push_back(s);
    }
    S = a; // 将 a 赋值给 S
}
```



5.24

```markdown
**哈希表7.赎金信**
判断一个字符串能不能由另一个字符串中的字母构成，用一个数组存储各字母出现次数即可。
```

```c++
**字符串4.翻转字符串里的单词**
这题很好，分三步：
1.去除多余空格（首、尾以及单词之间多余的）
2.翻转整个字符串
3.对其中每个单词再翻转

    void rever(string &s, int left, int right){//左闭右闭的翻转
        while(left < right){
            swap(s[left++], s[right--]);
        }
    }
    void yichu(string &s){
        int slow = 0;
        for(int i=0; i<s.size(); i++){//整体思想参考https://programmercarl.com/0027.移除元素.html
            if(s[i] != ' '){//遇到非空格就处理，即删除所有空格。
                if(slow != 0) s[slow++] = ' ';//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while(i<s.size() && s[i] != ' ') //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }
    string reverseWords(string s) {
        yichu(s);
        rever(s, 0, s.size()-1);
        int start = 0;
        for(int i=0; i<=s.size(); i++){//这里是<=，因为i可能等于s.size()
            if(i==s.size() || s[i] == ' '){
                rever(s, start, i-1);
                start = i+1;
            }
        }
        return s;
    }
```



5.25

```markdown
**哈希表8.三数之和**
for循环定i，然后用双指针收缩。注意点在于nums[i]的去重以及找到一个三元组之后nums[left]、nums[right]的去重。
int left = i + 1;
int right = nums.size() - 1;
```



```c++
**字符串5.右旋转字符串**
学到一个新的处理字符串的函数substr()，有两种常见用法：
1.substr(pos, len)：从字符串的位置 pos 开始，提取长度为 len 的子字符串。
2.substr(pos)：从字符串的位置 pos 开始，提取直到字符串的末尾的子字符串。

本题右旋转字符串函数：
void right(string &s, int k){
    int n = s.size();
    k %= n; // 取模确保移动的位数在字符串长度范围内
    string tmp1 = s.substr(0, n - k); // 截取移动后位于末尾的部分
    string tmp2 = s.substr(n - k); // 截取移动后位于开头的部分
    s = tmp2 + tmp1;
}
```



5.26

```markdown
**哈希表9.四数之和**
和三数之和差不多，相当于吧O(n^4)的问题转化为O(n^3)的问题，在三数之和的基础上多套一层循环。
```

```markdown
**字符串6.实现strStr()**
字符串中的find()，比如在str字符串中搜索ab，表达式str.find("ab")的值为ab子字符串在字符串中的起始位置。
如果要实现内部细节，那就涉及到kmp算法。
手撕kmp不好记，了解原理。
```



5.27

```c++
**字符串7.重复的子字符串**
判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，要刨除 s + s 的首字符和尾字符，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

注意点：npos 是 std::string 类的静态成员常量，表示字符串中没有匹配项的特殊值。
    
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
        if (t.find(s) != std::string::npos) return true; // 为什么字符串的find函数没找到返回的是npos而不是end()呢，因为字符串可以包含空字符（\0），所以无法简单地返回一个指向结尾的迭代器。
        return false;
    }
```

```c++
**栈与队列4.有效的括号**
括号匹配，栈的经典应用。
注意点：匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了。

    bool isValid(string s) {
        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    }
```



5.28

```markdown
**栈与队列5.删除字符串中的所有相邻重复项**
用栈来处理。
注意点：在用top()获取栈顶元素要先判断这个栈非空。
```



```markdown
**二叉树1.二叉树理论基础****二叉树2.二叉树的递归遍历**
```



5.29

```markdown
**栈与队列6.逆波兰表达式求值**
注意函数的使用：isdigit(),stoi()字符串转整数
```

```c++
**二叉树3.二叉树的迭代遍历**
前序：中左右，因为栈先进后出的特性，所以入栈是右左
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            result.push_back(node->val);
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return result;
    }
    
后序：左右中，只需要在前序的基础上修改一下左右节点入栈顺序，得到result数组之后再翻转就得到了结果
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            st.pop();
            result.push_back(node->val);
            if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
            if (node->right) st.push(node->right); // 空节点不入栈
        }
        reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
        return result;
    }

中序：左中右。下次写的时候要注意while循环内部的条件是什么。
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
```

5.30

```markdown
**栈与队列7.滑动窗口最大值**
未解决
```

```c++
**二叉树5.二叉树的层序遍历**
代码如下
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
```

5.31

```c++
**栈与队列8.前k个高频元素**
关键点：堆的使用，堆是用优先队列创建的，默认而言，创建的是大顶堆，也就是最大的元素在堆顶。
本题因为要维护k个最大元素，所以用小顶堆把小的元素从堆顶弹出，留下k个最大的元素。所以result数组最后需要翻转。
    // 小顶堆
    class myconparison{
    public:
        bool operator()(const pair<int,int> &lhs, const pair<int,int> &rhs){
            return lhs.second > rhs.second;// 出现频率小的优先
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> map;
        for(int i=0; i<nums.size(); i++){
            map[nums[i]]++;
        }
        // 定义最小堆
        priority_queue<pair<int,int>, vector<pair<int,int>>, myconparison> pri_que;
         // 遍历 unordered_map，将元素插入最小堆
        for(const auto& entry : map){
            pri_que.push(entry);
            // 如果堆的大小超过 k，弹出堆顶元素
            if(pri_que.size() > k){
                pri_que.pop();
            }
        }
        // 从堆中取出元素，存入结果向量
        vector<int> result;
        while(!pri_que.empty()){
            result.push_back(pri_que.top().first);
            pri_que.pop();
        }
        // 由于优先队列无法保证顺序，需要反转结果向量
        reverse(result.begin(), result.end());
        return result;
    }
```



6.6

```c++
**二叉树6.翻转二叉树**
自己写的：
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL) return root;
        TreeNode* cur = root;
        if(cur == NULL){
            return NULL;
        }
        else{
            TreeNode* node = root->left;
            root->left = root->right;
            root->right = node;
            invertTree(root->left);
            invertTree(root->right);
        }
        return root;
    }
最简递归写法：
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
//注意swap()的用法；自己写的代码片段有重复
//当然本题使用迭代法也是一样的，最主要的就是需要遍历一下二叉树的每个节点，以交换左右子树
```

```c++
**回溯1.理论****回溯2.组合**
//注意回溯的一个大致结构，关键点在于选取多少个参数，startindex用来记录本层递归的中，集合从哪里开始遍历
private:
    vector<vector<int>> result; // 存放符合条件结果的集合
    vector<int> path; // 用来存放符合条件结果
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n; i++) {
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1); // 递归
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        result.clear(); // 可以不写
        path.clear();   // 可以不写
        backtracking(n, k, 1);
        return result;
    }
```

6.8

```c++
**二叉树8.对称二叉树**
递归比较节点
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
```



```c++
**回溯4.组合总和三**
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startindex, int sum){
        if (sum > n) { // 剪枝操作
            return; 
        }
        if(path.size() == k){
            if(sum == n)
                result.push_back(path);
            return;            
        }
        for(int i=startindex; i<=9 - (k - path.size()) + 1; i++){//剪枝
            path.push_back(i);
            backtracking(n,k,i+1,sum+i);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(n,k,1,0);
        return result;
    }
```

6.9

```markdown
**二叉树9.二叉树的最大深度**
**二叉树10.二叉树的最小深度**
可以用递归或者遍历的方法做。
```

```c++
**回溯5.电话号码的字母组合**
这题属于是回溯法的经典应用了，首先明确回溯法的结构：
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
下图很重要，遇到问题先用类似下图的形式来分解，for循环横向遍历，递归纵向遍历。回溯函数的
```

![电话号码的字母组合](C:\Users\93781\Desktop\c++runrunrun\刷题记录\电话号码的字母组合.jpg)

6.10

```c++
**二叉树11.完全二叉树的节点个数**
如果当做是普通二叉树，两行代码递归解决。
但是如何利用完全二叉树的性质解题？
关键点：判断其子树是不是满二叉树，如果是则利用公式计算这个子树（满二叉树）的节点数量，如果不是则继续递归。
那如何判断一棵树是否是满二叉树呢？
一直往左走的深度等于一直往右走的深度就是满二叉树。
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;
        TreeNode* left = root->left;
        TreeNode* right = root->right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left) {  // 求左子树深度
            left = left->left;
            leftDepth++;
        }
        while (right) { // 求右子树深度
            right = right->right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
```

![完全二叉树的节点个数](C:\Users\93781\Desktop\c++runrunrun\刷题记录\完全二叉树的节点个数.png)

```c++
**回溯7.组合总和**
一开始我使用的方法和之前的回溯一样，但是出现的问题是包含了重复的元组，如下所示。
输出
[[2,2,3],[2,3,2],[3,2,2],[7]]
预期结果
[[2,2,3],[7]]
如何去除重复的元组呢？
问题出在没有去重和回溯的候选数未限制下一个递归从当前数开始。每次递归从头开始，导致生成的组合里出现了重复的顺序。需要在backtracking函数中加上一个startindex参数。
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startindex){
        if(sum > target) return;
        if(sum == target){
            result.push_back(path);
            return;
        }
        for(int i=startindex; i<candidates.size(); i++){
            path.push_back(candidates[i]);
            backtracking(candidates,target,sum+candidates[i], i);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtracking(candidates, target, 0, 0);
        return result;
    }
```

![组合总和](C:\Users\93781\Desktop\c++runrunrun\刷题记录\组合总和.png)



6.11

```c++
**二叉树12.平衡二叉树**
同样是用回溯的方法，判断左右子树高度差是否大于1。
    int getHeight(TreeNode* root){
        if(root == NULL) return 0;
        int leftheight = getHeight(root->left);
        if(leftheight == -1) return -1;
        int rightheight = getHeight(root->right);
        if(rightheight == -1) return -1;
        int result;
        if(abs(leftheight-rightheight)>1){
            result = -1;
        }else{
            result = 1+max(leftheight,rightheight);
        }
        return result;
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
```

```c++
**回溯8.组合总和二**
和组合总和的不同点在于candidate数组中有重复元素，要排序，进行树层去重，画图会比较直观。再引入used数组来帮助去重。
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startindex, vector<bool>& used){
        if(sum > target) return;
        if(sum == target){
            result.push_back(path);
            return;
        }
        for(int i=startindex; i<candidates.size(); i++){
            // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 要对同一树层使用过的元素进行跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
                continue;
            }
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates,target,sum+candidates[i], i+1, used);// 和39.组合总和的区别1，这里是i+1，每个数字在每个组合中只能使用一次
            used[i] = false;
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        // 首先把给candidates排序，让其相同的元素都挨在一起。
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0, 0, used);
        return result;
    }
```

![组合总和二](C:\Users\93781\Desktop\c++runrunrun\刷题记录\组合总和二.jpg)

6.12

```c++
**二叉树13.二叉树的所有路径**
这题有一些不同，改变了回溯的结构，将判断条件变为只判断左右孩子为空而不是节点为空，因为我们只需要获取叶子结点的值。
第二，为了比较方便地添加"->"，将path也加入回溯函数的参数中。
    vector<string> result;
    void backtracking(TreeNode* root, string path){
        path += to_string(root->val); // 中
        if(root->left == NULL && root->right == NULL){
            result.push_back(path);
            return;
        }
        if(root->left) backtracking(root->left, path+"->");//左
        if(root->right) backtracking(root->right, path+"->");//右
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string path;
        if (root == NULL) return result;
        backtracking(root, path);
        return result;
    }
```

```c++
**回溯9.分割回文串**
对字符串的处理理解不够，例如substr函数的应用，如何获取回文串的区间等等。
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome(s, startIndex, i)) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
                backtracking(s, i + 1); // 寻找i+1为起始位置的子串
                path.pop_back(); // 回溯过程，弹出本次已经添加的子串
            } else {                                // 不是回文，跳过
                continue;
            }
        }
    }
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
public:
    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        backtracking(s, 0);
        return result;
    }
```

6.13

```markdown
**二叉树14.周末总结**
```

```c++
**回溯10.复原ip地址**
详细理解一下以下两行：
result.push_back(path.substr(0, path.size() - 1));
path.erase(path.end() - str.size() - 1, path.end());
public:
    vector<string> result;
    string path;
    bool isvalid(string s, int left, int right){
        string str = s.substr(left, right - left + 1);
        if(str.size() < 1 || str.size() > 3) return false;// 检查子字符串长度
        if(str[0] == '0' && str.size() > 1) return false;// 检查前导零（排除 "0" 的情况）
        int num = stoi(str);
        if(num>=0 && num<=255) return true;
        return false;

    }
    void backtracking(const string& s, int startindex, int sum){
        if(startindex == s.size() && sum == 4){
            result.push_back(path.substr(0, path.size() - 1)); // 去掉最后一个多余的点
            return;
        }
        for(int i=startindex; i<s.size(); i++){
            if(isvalid(s, startindex, i)){
                string str = s.substr(startindex, i-startindex+1);
                path += str + ".";
                backtracking(s, i+1, sum+1);
                path.erase(path.end() - str.size() - 1, path.end());//移除 str.size() + 1 个字符（包括子字符串和点 .）
            }else break;
            
        }
    }
    vector<string> restoreIpAddresses(string s) {
        result.clear();
        path.clear(); //初始化和重置状态，确保每次调用该函数时不受之前调用的影响
        backtracking(s,0,0);
        return result;
    }
```

![earse函数](C:\Users\93781\Desktop\c++runrunrun\刷题记录\earse函数.jpg)



```markdown
**二叉树15.左叶子之和**
拿捏。
```

```markdown
**回溯11.子集问题**
树形图如下
什么时候剩余集合为空呢？
就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了
```

![子集问题](C:\Users\93781\Desktop\c++runrunrun\刷题记录\子集问题.png)

```c++
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startindex){
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if(startindex >= nums.size()){
            return;
        }
        for(int i = startindex; i<nums.size();i++){
            path.push_back(nums[i]);
            backtracking(nums, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
```

6.16

```c++
**二叉树16.找树左下角的值**
方法1.层序遍历轻松解决。
方法2.递归。有一个注意点，能满足最新深度大于maxDepth的情况必定是当前深度左边第一个节点。
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {//能满足这个条件的必定是当前深度左边第一个节点
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            traversal(root->left, depth + 1); // 隐藏着回溯
        }
        if (root->right) {
            traversal(root->right, depth + 1); // 隐藏着回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
```

```c++
**回溯13.子集二**
和组合总和二的去重思路是一样的，但是自己写的时候有一些问题。
问题一：continue写成break，导致某些子集被遗漏。
问题二：忘记对nums数组进行排序，去重之前是需要排序的。
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startindex, vector<bool>& used){
        result.push_back(path);
        if(startindex >= nums.size()){
            return;
        }
        for(int i=startindex; i<nums.size(); i++){
            if(i>0 && nums[i] == nums[i-1] && used[i-1] == false){
                continue;
            }else{
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, i+1, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(),0);
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0, used);
        return result;
    }
```

6.17

```markdown
**二叉树17.路径总和**
也是回溯。
```

```c++
**回溯14.递增子序列**
这题和之前组合总和二的去重又有些不一样，本题不能进行排序操作。解这种题，画图更清晰一些。
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startindex){
        if(path.size()>1){
            result.push_back(path);
        }
        unordered_set<int> uset; // 使用set来对本层元素进行去重
        for(int i=startindex; i<nums.size();i++){
            if((!path.empty() && path.back()>nums[i]) || uset.find(nums[i]) != uset.end()){
                continue;
            }
            uset.insert(nums[i]);// 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums,0);
        return result;
    }
```

![非递减子序列](C:\Users\93781\Desktop\c++runrunrun\刷题记录\非递减子序列.jpg)

```c++
**二叉树18.从中序和后序遍历序列构造二叉树**
这题值得回头好好看一下。
步骤：
第一步：如果数组大小为零的话，说明是空节点了。
第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
第五步：切割后序数组，切成后序左数组和后序右数组
第六步：递归处理左区间和右区间
private:
    // 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)
    TreeNode* traversal (vector<int>& inorder, int inorderBegin, int inorderEnd, vector<int>& postorder, int postorderBegin, int postorderEnd){
        if(postorderBegin == postorderEnd) return NULL;
        int rootValue = postorder[postorderEnd-1];
        TreeNode* root = new TreeNode(rootValue);

        if(postorderEnd - postorderBegin == 1) return root;

        int delimiterIndex;
        for(delimiterIndex = inorderBegin; delimiterIndex < inorderEnd; delimiterIndex++){
            if(inorder[delimiterIndex] == rootValue) break;
        }
        // 切割中序数组
        // 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)
        int leftInorderBegin = inorderBegin;
        int leftInorderEnd = delimiterIndex;
        // 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)
        int rightInorderBegin = delimiterIndex + 1;
        int rightInorderEnd = inorderEnd;

        // 切割后序数组
        // 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)
        int leftPostorderBegin =  postorderBegin;
        int leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; // 终止位置是 需要加上 中序区间的大小size
        // 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)
        int rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);
        int rightPostorderEnd = postorderEnd - 1; // 排除最后一个元素，已经作为节点了
        root->left = traversal(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);
        root->right = traversal(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);
        return root;
    } 
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        // 左闭右开的原则
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
```

```c++
**回溯15.全排列**
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, vector<bool>& used){
        if(path.size() >= nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0; i<nums.size(); i++){
            if(used[i] == false){
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums,used);
                path.pop_back();
                used[i] = false;
            }else{continue;}
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(),0);
        backtracking(nums,used);
        return result;
    }
```

![全排列](C:\Users\93781\Desktop\c++runrunrun\刷题记录\全排列.jpg)

6.19

```c++
**二叉树19.最大二叉树**
也是一个分割的问题，和上个二叉树的题型比较类似。
private:
    //左闭右开[left,right)
    TreeNode* construct(vector<int>& nums, int left, int right){
        if (left >= right) return nullptr;
        int max_value = nums[left];
        int index = left;
        // 遍历数组找到最大值及其下标
        for (int i = left+1; i < right; ++i) {
            if (nums[i] > max_value) {
                max_value = nums[i];
                index = i;
            }
        }
        TreeNode* node = new TreeNode(max_value);
        node->left = construct(nums, left, index);
        node->right = construct(nums, index+1, right);
        return node;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return construct(nums, 0, nums.size());    
    }
```

```c++
**回溯16.全排列2**
相比于全排列1，增加了元素重复，那只需要在全排列1的代码基础上加上一句判断书层重复的代码，以及对nums数组排序即可。
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, vector<bool>& used){
        if(path.size() >= nums.size()){
            result.push_back(path);
            return;
        }
        for(int i=0; i<nums.size(); i++){
            if(i>0 && nums[i]==nums[i-1] && used[i-1] == true) continue;
            if(used[i] == false){
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums,used);
                path.pop_back();
                used[i] = false;
            }else{continue;}
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(),0);
        sort(nums.begin(),nums.end());
        backtracking(nums,used);
        return result;
    }
```

6.20

```c++
**二叉树21.合并二叉树**
确定终止条件，写出递归。
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1 == NULL) return root2;
        if(root2 == NULL) return root1;
        root1->val += root2->val;
        root1->left = mergeTrees(root1->left, root2->left);
        root1->right = mergeTrees(root1->right, root2->right);
        return root1;
    }
```

```c++
**回溯19.重新安排行程**
hard,难度在于如何选择数据结构来存储航班信息，这里使用
    unordered_map<出发机场, map<到达机场, 航班次数>> targets

class Solution {
private:
// unordered_map<出发机场, map<到达机场, 航班次数>> targets
unordered_map<string, map<string, int>> targets;
bool backtracking(int ticketNum, vector<string>& result){
    if(result.size() == ticketNum + 1){
        return true;
    }
    for(pair<const string, int>& target : targets[result[result.size() - 1]]){//result 是一个字符串向量，记录了目前为止的行程。
    //result[result.size() - 1] 获取当前行程的最后一个机场（即当前所在的机场）。
    //targets[result[result.size() - 1]] 获取从当前机场出发的所有目的地机场及其对应的航班次数，这是一个 map<string, int> 类型的数据。
        if(target.second > 0){// 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            if(backtracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
        }
    }
    return false;
}
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        vector<string> result;
        for(const vector<string>& vec : tickets){
            targets[vec[0]][vec[1]]++;
        }
        result.push_back("JFK");//起始机场
        backtracking(tickets.size(), result);
        return result;
    }
};
```

6.21

```c++
**二叉树22.二叉搜索树中的搜索**
小小递归，拿捏。
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == NULL) return NULL;
        if(root->val == val) return root;
        TreeNode* left = searchBST(root->left, val);
        TreeNode* right = searchBST(root->right, val);
        if(left) return left;
        if(right) return right;
        return NULL;
    }
```

```c++
**回溯20.N皇后**
算是一道非常经典的题目了。
private:
    vector<vector<string>> result;
    void backtracking(int n, int row, vector<string>& chessboard){
        if(row == n){
            result.push_back(chessboard);
            return;
        }
        for(int i=0; i<n; i++){
            if(isValid(row, i, chessboard, n)){
                chessboard[row][i] = 'Q';
                backtracking(n, row+1, chessboard); 
                chessboard[row][i] = '.';            
            }
        }
    }
    bool isValid(int row, int col, vector<string>& chessboard, int n){
        for(int i=0; i<row; i++){
            if(chessboard[i][col] == 'Q')
                return false;
        }
        for(int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--){
            if(chessboard[i][j] == 'Q')
                return false;
        }
        for(int i = row - 1, j = col + 1; i>=0 && j<n; i--,j++){
            if(chessboard[i][j] == 'Q')
                return false;
        }
        return true;
    }
public:
    vector<vector<string>> solveNQueens(int n) {
        result.clear();
        vector<string> chessboard(n, std::string(n, '.'));
        backtracking(n,0,chessboard);
        return result;
    }
```

6.23

```c++
**二叉树23.验证二叉搜索树**
中序遍历存储到数组里，只要是递增的，就是二叉搜索树。
public:
    vector<int> vec;
    void travel(TreeNode* root){
        if(root == NULL) return;
        if(root->left) travel(root->left);
        vec.push_back(root->val);
        if(root->right) travel(root->right);
    }
    bool isValidBST(TreeNode* root) {
        travel(root);
        for(int i=1;i<vec.size();i++){
            if(vec[i-1]>=vec[i]){
                return false;
            }
        }
        return true;
    }
```

```c++
**回溯22.解数独**
回溯的经典题目，二维回溯。
private:
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // 遍历行
        for (int j = 0; j < board[0].size(); j++) { // 遍历列
            if (board[i][j] == '.') {
                for (char k = '1'; k <= '9'; k++) {     // (i, j) 这个位置放k是否合适
                    if (isValid(i, j, k, board)) {
                        board[i][j] = k;                // 放置k
                        if (backtracking(board)) return true; // 如果找到合适一组立刻返回
                        board[i][j] = '.';              // 回溯，撤销k
                    }
                }
                return false;  // 9个数都试完了，都不行，那么就返回false
            }
        }
    }
    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
}
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // 判断行里是否重复
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // 判断列里是否重复
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
```

```c++
**hot100——49.字母异位词分组**
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        //将排序后的字符串作为map的键，未排序的str作为值，以达到分类的效果
        unordered_map<string, vector<string>> map;
        for(string& str:strs){
            string key = str;
            sort(key.begin(), key.end());
            map[key].push_back(str);
        }
        vector<vector<string>> vec;
        for(auto it=map.begin(); it != map.end(); it++){
            vec.push_back(it->second);
        }
        return vec;
    }
```

6.24

```c++
**二叉树24.二叉搜索树的最小绝对差**
和23题差不多，先用数组存放中序顺序，这就是有序数组，再求最小绝对差。
private:
    vector<int> vec;
    void backtracking(TreeNode* root){
        if(root == NULL) return;
        if(root->left) backtracking(root->left);
        vec.push_back(root->val);
        if(root->right) backtracking(root->right);
    }
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        backtracking(root);
        if(vec.size() < 2) return 0;
        int result = INT_MAX;
        for(int i=1; i<vec.size(); i++){
            result = min(result, vec[i]-vec[i-1]);
        }
        return result;
    }
```

```c++
**贪心1.贪心算法理论基础****贪心2.分发饼干**
优先满足胃口小的。
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int result = 0;
        for(int i=0,j=0; i<g.size() && j<s.size();){
            if(g[i]<=s[j]){
                result++;
                i++;j++;
            }else{
                j++;
            }
        }
        return result;
    }
```

```c++
**hot100——128.最长连续序列**
有点东西的，考查对哈希结构的使用，map存储每个端点值以及区间的长度。
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int, int> mp;
        int max_length = 0;
        for(int num:nums){
            if(mp.find(num) == mp.end()){// 如果当前数字不在哈希表中，开始处理
                // 获取当前数字的左边和右边连续序列的长度
                int left = mp.find(num-1) != mp.end() ? mp[num-1] : 0;
                int right = mp.find(num+1) != mp.end() ? mp[num+1] : 0;
                int cur_length = 1 + left + right;
                max_length = max(max_length, cur_length);
                mp[num] = cur_length;// 更新当前数字及其连续序列两端的长度
                mp[num-left] = cur_length;
                mp[num+right] = cur_length; 
            }
        }
        return max_length;
    }
```

6.25

```markdown
**二叉树25.二叉搜索树中的众数**
一样的，先将二叉搜索树转化为有序数组，然后用unordered_map来找有序数组中的众数。
```

```c++
**贪心3.摆动序列**
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff
            }
        }
        return result;
    }
```

6.26

```c++
**二叉树26.二叉树的最近公共祖先**
首先思考如何自底向上查找，再想到回溯，想到后序遍历，左右中。

public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == NULL) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q); //左
        TreeNode* right = lowestCommonAncestor(root->right, p, q);  //右
        if (left != NULL && right != NULL) return root; //中

        if(left != NULL && right == NULL) return left; //中
        else if(left == NULL && right != NULL) return right; //中
        else return NULL;   //中
    }
```

```c++
**贪心4.最大子序和**
局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
public:
    int maxSubArray(vector<int>& nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            count += nums[i];
            if (count > result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count;
            }
            if (count <= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
        return result;
    }
```

6.27

```markdown
**二叉树28.二叉搜索树的最近公共祖先**
继续用最近公共祖先的方法做。
```

```c++
**贪心6.买卖股票的最佳时机二**
方法一、贪心
    int maxProfit(vector<int>& prices) {//局部最优：收集每天的正利润，全局最优：求得最大利润。
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result; 
    }
方法二、动态规划。
public:
    int maxProfit(vector<int>& prices) {
        //dp[i][0] 表示第i天持有股票所得现金。
        //dp[i][1] 表示第i天不持有股票所得最多现金
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0; 
        for(int i=1; i<len; i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            //如果第i天持有股票即dp[i][0]
            //第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
            //第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
            //如果第i天不持有股票即dp[i][1]
            //第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
            //第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] + dp[i - 1][0]
        }
        return dp[len-1][1];
    }
```

7.1

```C++
**二叉树29.二叉搜索树中的插入操作**
伪装的中等题的简单题
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            return new TreeNode(val);
        }
        if (val < root->val) {
            root->left = insertIntoBST(root->left, val);
        } else {
            root->right = insertIntoBST(root->right, val);
        }
        return root;
    }
```

```C++
**贪心7.跳跃游戏**
主要就是维护一个能到达的最远位置。
public:
    bool canJump(vector<int>& nums) {
        int length = 0;// 能到达的最远位置
        for(int i=0; i<nums.size()-1;i++){
            if(i>length) return false;// 当前索引大于能到达的最远位置，无法到达终点
            length = max(length, i+nums[i]);// 更新能到达的最远位置
        }
        if(length >= nums.size()-1) return true;// 能到达或超过终点，返回true
        return false;
    }
```

7.2

```c++
**二叉树30.删除二叉搜索树中的节点**
分情况讨论，五种情况
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root == NULL) return root;//第一种情况：没找到删除的节点
        if(root->val == key){
            //第二种情况：左右孩子都为空（叶子节点），直接删除节点
            if(root->left == NULL && root->right == NULL){
                delete root;
                return NULL;
            }
            //第三种情况：左孩子为空，右孩子非空，删除节点，右孩子补位
            else if(root->left == NULL){
                TreeNode* node = root->right;
                delete root;
                return node;
            }
            //第四种情况：右孩子为空，左孩子非空，删除节点，左孩子补位
            else if(root->right == NULL){
                TreeNode* node = root->left;
                delete root;
                return node;
            }
            //第五种情况：左右孩子都非空，将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            else{
                TreeNode* cur = root->right;//找右子树最左面的节点
                while(cur->left != NULL){
                    cur = cur->left;
                }
                cur->left = root->left;
                TreeNode* tmp = root;
                root = root->right;
                delete tmp;
                return root;
            }
        }
        if(root->val > key) root->left = deleteNode(root->left, key);
        if(root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
```

```C++
**贪心8.跳跃游戏2**
相比于跳跃游戏，本题需要维护当前覆盖最远距离和下一步覆盖最远距离。
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;
        int curDistance = 0;    // 当前覆盖最远距离下标
        int ans = 0;            // 记录走的最大步数
        int nextDistance = 0;   // 下一步覆盖最远距离下标
        for (int i = 0; i < nums.size() - 1; i++) {
            nextDistance = max(nums[i] + i, nextDistance);  // 更新下一步覆盖最远距离下标
            if (i == curDistance) {                         // 遇到当前覆盖最远距离下标
                ans++;                                  // 需要走下一步
                curDistance = nextDistance;             // 更新当前覆盖最远距离下标（相当于加油了）
                if (nextDistance >= nums.size() - 1) break;  // 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束
            }
        }
        return ans;
    }
```

7.3

```C++
**二叉树31.修剪二叉搜索树**
有点难度，需要对递归深入理解。
对于不在区间内的节点，我们用两个if条件来返回这个不在区间内的节点下面可能在区间内的节点。这样操作就算是头结点不在区间内，也可以处理。
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr ) return nullptr;
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
            return right;
        }
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点
            return left;
        }
        root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子
        root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子
        return root;
    }
```

```markdown
**贪心9.k次取反后最大化的数组和**
呃。。。
```

7.4

```C++
**二叉树32.将有序数组转换为二叉搜索树**
和6.19日的最大二叉树相似，都是通过数组来递归构建二叉树。
注意一个点，就是二分法中的mid = left + ((right - left) / 2)不会造成数组越界。
public:
    TreeNode* construst(vector<int>& nums, int left, int right){//左闭右闭
        if(left > right) return NULL;
        int mid = left + ((right - left) / 2);//如果 (left + right) / 2 可能会造成数值越界
        TreeNode* node = new TreeNode(nums[mid]);
        node->left = construst(nums,left,mid-1);
        node->right = construst(nums,mid+1,right);
        return node;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = construst(nums, 0, nums.size()-1);
        return root;
    }
```

```C++
**贪心11.加油站**
局部最优：当前累加rest[i]（就是gas[i]-cost[i]）的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
```

7.5

```c++
**二叉树32.把二叉搜索树转换为累加树**
第一步，确定遍历顺序，如何累加。
第二步，需要一个pre来记录前一个节点的数值。
private:
    int pre = 0; //记录前一个节点的数值
    void travel(TreeNode* root){//右中左遍历，将节点相加
        if(root == NULL) return;
        travel(root->right);
        root->val += pre;
        pre = root->val; 
        travel(root->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        int pre = 0;
        travel(root);
        return root;
    }
```

```C++
**贪心12.分发糖果**
一次单向遍历是不够的，需要双向的两次遍历。
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        if (n == 0) return 0;
        if (n == 1) return 1;
        // 初始化每个孩子的糖果数为1
        vector<int> candies(n, 1);
        // 从左到右遍历，保证右边评分高的孩子糖果更多
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }
        // 从右到左遍历，保证左边评分高的孩子糖果更多
        for (int i = n - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candies[i] = max(candies[i], candies[i + 1] + 1);
            }
        }
        // 计算总糖果数
        int result = 0;
        for (int i = 0; i < n; i++) {
            result += candies[i];
        }

        return result;
    }
```

7.6

```markdown
**贪心13.柠檬水找零**
对于20美元，优先看有没有10美元的找零，再看5美元的找零。
```

```markdown
**动态规划2.斐波那契数**
**动态规划3.爬楼梯**
最简单的动态规划
```

```markdown
**hot100——11.盛最多水的容器**
利用双指针法，抓住容积取决于最低的木板，左边低就左指针向内收缩，右边低就右指针向内收缩。
```

7.8

```c++
**贪心14.根据身高重建队列**
插入操作好好看好好学，这个属于是语法问题了

//链表操作
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();//创建一个链表迭代器 it，并将其初始化为链表头部。
            while (position--) { // 寻找插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
	
	
	//vector插入
	    static bool cmp(const vector<int>& a, const vector<int>& b) {//身高由大到小排
        if (a[0] == b[0]) return a[1] < b[1];   //身高相同，按第二参数由小到大排
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(),cmp);
        vector<vector<int>> que;    //新建一个二维数组一个个插入
        for(int i=0; i<people.size(); i++){
            int position = people[i][1];
            que.insert(que.begin() + position, people[i]);  //这是什么操作？好好看好好学啊
        }
        return que;
    }
```

```markdown
**动态规划4.用最小花费爬楼梯**
常规
```

7.9

```c++
**贪心17.用最少数量的箭引爆气球**
第一排序，第二比较，第三更新值
public:
    static bool cmp(const vector<int>& a, const vector<int>& b){
        return a[0] < b[0];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.size() == 1) return 1;
        int result = 1;
        sort(points.begin(), points.end(), cmp);//按照左侧x坐标进行从小到大排序
        for(int i=1; i<points.size(); i++){
            if(points[i][0] > points[i-1][1]) result++; //如果相邻两个气球没有交集，就多加一根针
            else{   //如果有交集，就更新当前的points[i]为两个气球的交集，再与下一个气球比较
                points[i][0] = max(points[i][0], points[i-1][0]);
                points[i][1] = min(points[i][1], points[i-1][1]);
            }
        }
        return result;
    }
```

```c++
**动态规划6.不同路径**
解决
**动态规划7.不同路径二**
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        for(int i=0; i<m; i++){
            if(obstacleGrid[i][0] == 1) break; //初始化第一列为1，因为只有一种走法
            dp[i][0] = 1;
        }
        for(int j=0; j<n; j++){
            if(obstacleGrid[0][j] == 1) break; //初始化第一行为1，因为只有一种走法
            dp[0][j] = 1;
        }
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                if(obstacleGrid[i][j] == 1) dp[i][j] = 0; //障碍物直接设置为0就行
                else{
                    dp[i][j] = dp[i][j-1] + dp[i-1][j];
                }
            }
        }
        return dp[m-1][n-1];
    }
```

7.10

```markdown
**贪心18.无重叠区间**
和前一天的引爆气球比较相似
```

```C++
**动态规划8.整数拆分**
public:
    int integerBreak(int n) {//dp[i]表示拆分数字i可得到的最大乘积
        vector<int> dp(n+1,0);
        dp[2] = 1;
        for(int i=3; i<=n; i++){
            for(int j=1; j<i; j++){
                dp[i] = max(dp[i],max((i-j)*j, dp[i-j]*j));
            }
        }
        return dp[n];
    }
```

```c++
**hot100——42. 接雨水**
双指针法
    
使用 height[left] 和 height[right] 的值更新 leftMax 和 rightMax 的值；
如果 height[left]<height[right]，则必有 leftMax<rightMax，下标 left 处能接的雨水量等于 leftMax−height[left]，将下标 left 处能接的雨水量加到能接的雨水总量，然后将 left 加 1（即向右移动一位）；
如果 height[left]≥height[right]，则必有 leftMax≥rightMax，下标 right 处能接的雨水量等于 rightMax−height[right]，将下标 right 处能接的雨水量加到能接的雨水总量，然后将 right 减 1（即向左移动一位）。
public:
    int trap(vector<int>& height) {
        int result = 0;
        int left = 0, right = height.size() - 1;
        int leftmax = 0, rightmax = 0;
        while(left < right){
            leftmax = max(leftmax, height[left]);
            rightmax = max(rightmax, height[right]);
            if(height[left] < height[right]){ //必有 leftMax<rightMax
                result += leftmax - height[left];
                left++;
            }else{ //必有 leftMax≥rightMax
                result += rightmax - height[right];
                right--;
            }
        }
        return result;
    }
```

7.11

```c++
**贪心19.划分字母区间**
public:
    vector<int> partitionLabels(string s) {
        int hash[27] = {0};// i为字符，hash[i]为字符出现的最后位置
        vector<int> result;
        for(int i=0; i<s.size();i++){// 统计每一个字符最后出现的位置
            hash[s[i]-'a'] = i;
        }
        int tmp = 0;
        int right = 0;
        for(int i=0; i<s.size(); i++){
            tmp++;
            right = max(right, hash[s[i] - 'a']);// 找到字符出现的最远边界
            if(i == right){
                result.push_back(tmp);
                tmp = 0;
            }
        }
        return result;
    }
```

```c++
**动态规划9.不同的二叉搜索树**
困难
    int numTrees(int n) {
        vector<int> dp(n+1);//dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
        dp[0] = 1;
        for(int i=1; i<=n; i++){
            for(int j=1; j<=i; j++){
                dp[i] += dp[i-j] * dp[j-1];
            } 
        }
        return dp[n];
    }
```

7.13

```c++
**贪心20.合并区间**
第一排序，第二比较，第三更新值，和气球爆破很相似
public:
    static bool cmp(const vector<int>& a, const vector<int>& b){
        return a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {//依然跟爆破气球的题很相似
        if(intervals.size() == 1) return intervals;
        sort(intervals.begin(), intervals.end(), cmp);
        for(int i=1; i<intervals.size(); i++){
            if(intervals[i][0] > intervals[i-1][1]) continue;
            else{
                intervals[i][0] = intervals[i-1][0];
                intervals[i][1] = max(intervals[i-1][1], intervals[i][1]);
                intervals.erase(intervals.begin()+i-1);
                i--;//合并后的区间要与下一个区间比较
            }
        }
        return intervals;
    }

方法二：直接在result结果集中进行操作（合并或者添加）
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> result;
        if (intervals.size() == 0) return result; // 区间集合为空直接返回
        // 排序的参数使用了lambda表达式
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){return a[0] < b[0];});

        // 第一个区间就可以放进结果集里，后面如果重叠，在result上直接合并
        result.push_back(intervals[0]); 

        for (int i = 1; i < intervals.size(); i++) {
            if (result.back()[1] >= intervals[i][0]) { // 发现重叠区间
                // 合并区间，只更新右边界就好，因为result.back()的左边界一定是最小值，因为我们按照左边界排序的
                result.back()[1] = max(result.back()[1], intervals[i][1]); 
            } else {
                result.push_back(intervals[i]); // 区间不重叠 
            }
        }
        return result;
    }
```

```c++
**动态规划10.01背包**
dp[i][j]表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
//二维dp数组实现
#include <bits/stdc++.h>
using namespace std;

int n, bagweight;// bagweight代表行李箱空间
void solve() {
    vector<int> weight(n, 0); // 存储每件物品所占空间
    vector<int> value(n, 0);  // 存储每件物品价值
    for(int i = 0; i < n; ++i) {
        cin >> weight[i];
    }
    for(int j = 0; j < n; ++j) {
        cin >> value[j];
    }
    // dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化, 因为需要用到dp[i - 1]的值
    // j < weight[0]已在上方被初始化为0
    // j >= weight[0]的值就初始化为value[0]
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            // 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值
            // 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
    while(cin >> n >> bagweight) {
        solve();
    }
    return 0;
}


// 一维dp数组实现
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 读取 M 和 N
    int M, N;
    cin >> M >> N;

    vector<int> costs(M);
    vector<int> values(M);

    for (int i = 0; i < M; i++) {
        cin >> costs[i];
    }
    for (int j = 0; j < M; j++) {
        cin >> values[j];
    }

    // 创建一个动态规划数组dp，初始值为0
    vector<int> dp(N + 1, 0);

    // 外层循环遍历每个类型的研究材料
    for (int i = 0; i < M; ++i) {
        // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
        for (int j = N; j >= costs[i]; --j) {
            // 考虑当前研究材料选择和不选择的情况，选择最大值
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }

    // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
    cout << dp[N] << endl;

    return 0;
}
```

7.14

```c++
**贪心22. 单调递增的数字**
举例：98，一旦出现strNum[i - 1] > strNum[i]的情况（非单调递增），首先想让strNum[i - 1]--，然后strNum[i]给为9，这样这个整数就是89，即小于98的最大的单调递增整数。

public:
    int monotoneIncreasingDigits(int N) {
        string strNum = to_string(N);
        // flag用来标记赋值9从哪里开始
        // 设置为这个默认值，为了防止第二个for循环在flag没有被赋值的情况下执行
        int flag = strNum.size();
        for (int i = strNum.size() - 1; i > 0; i--) {
            if (strNum[i - 1] > strNum[i] ) {
                flag = i;
                strNum[i - 1]--;
            }
        }
        for (int i = flag; i < strNum.size(); i++) {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
```

```C++
**动态规划11.01背包（一维dp数组）**
// 一维dp数组实现
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 读取 M 和 N
    int M, N;
    cin >> M >> N;

    vector<int> costs(M);
    vector<int> values(M);

    for (int i = 0; i < M; i++) {
        cin >> costs[i];
    }
    for (int j = 0; j < M; j++) {
        cin >> values[j];
    }

    // 创建一个动态规划数组dp，初始值为0
    vector<int> dp(N + 1, 0);

    // 外层循环遍历每个类型的研究材料
    for (int i = 0; i < M; ++i) {
        // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
        for (int j = N; j >= costs[i]; --j) {
            // 考虑当前研究材料选择和不选择的情况，选择最大值
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }

    // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
    cout << dp[N] << endl;

    return 0;
}
```

7.15

```c++
**动态规划13.分割等和子集**
public:
    bool canPartition(vector<int>& nums) {
        //背包的体积为sum / 2
        //背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
        //背包如果正好装满，说明找到了总和为 sum / 2 的子集。
        //背包中每一个元素是不可重复放入。
        int sum = 0;
        // dp[i]中的i表示背包内总和
        // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
        // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
        sum = accumulate(nums.begin(), nums.end(), 0);
        vector<int> dp(10001, 0);
        if(sum%2 == 1) return false;
        int target = sum/2;
        for(int i=0; i<nums.size(); i++){
            for(int j=target; j>=nums[i]; j--){
                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i]);
            }
        }
        if(dp[target] == target){
            return true;
        }
        return false;
    }
```

```markdown
**图论1.图论理论基础**
```

7.16

```markdown
**hot100——118. 杨辉三角**
```

```markdown
**hot100——198. 打家劫舍**
```

7.17

```c++
**图论3.所有可达路径**
解法一，邻接矩阵
//邻接矩阵写法
#include<iostream>
#include<vector>
using namespace std;
vector<vector<int>> result;//收集符合条件的路径
vector<int> path; //1节点到终点的路径

void dfs(const vector<vector<int>> & graph, int x, int n){
    //当前遍历的节点x，到达节点n
    if(x == n){
        result.push_back(path);
        return ;
    }
    for(int i=1; i<=n; i++){// 遍历节点x链接的所有节点
        if(graph[x][i] == 1){// 找到 x链接的节点
            path.push_back(i);// 遍历到的节点加入到路径中来
            dfs(graph, i, n);// 进入下一层递归
            path.pop_back(); // 回溯，撤销本节点
        }
    }
}

int main(){
    int n, m, s, t;
    cin >> n >> m;
    // 节点编号从1到n，所以申请 n+1 这么大的数组
    vector<vector<int>> graph(n+1, vector<int>(n+1, 0));
    while(m--){
        cin >> s >> t;
         // 使用邻接矩阵 表示有向图，1 表示 s 与 t 是相连的
        graph[s][t] = 1;
    }
    path.push_back(1);// 无论什么路径已经是从0节点出发
    dfs(graph, 1, n);
    
    if(result.size() == 0) cout<<-1<<endl;
    for(const vector<int> &pa : result){
        for(int i=0; i<pa.size()-1; i++){
            cout<<pa[i]<<" ";
        }
        cout<<pa[pa.size()-1]<<endl;
    }
}



解法二，邻接表
//邻接表写法
#include<iostream>
#include<vector>
#include<list>
using namespace std;
vector<vector<int>> result;//收集符合条件的路径
vector<int> path; //1节点到终点的路径

void dfs(const vector<list<int>> & graph, int x, int n){
    //当前遍历的节点x，到达节点n
    if(x == n){
        result.push_back(path);
        return ;
    }
    for(int i : graph[x]){/// 找到 x指向的节点
        path.push_back(i);// 遍历到的节点加入到路径中来
        dfs(graph, i, n);// 进入下一层递归
        path.pop_back(); // 回溯，撤销本节点
    }
}

int main(){
    int n, m, s, t;
    cin >> n >> m;
    // 节点编号从1到n，所以申请 n+1 这么大的数组
    vector<list<int>> graph(n+1);//邻接表
    while(m--){
        cin >> s >> t;
         // 使用邻接矩阵 表示有向图，1 表示 s 与 t 是相连的
        graph[s].push_back(t);//链表尾部插入元素
    }
    path.push_back(1);// 无论什么路径已经是从0节点出发
    dfs(graph, 1, n);
    
    if(result.size() == 0) cout<<-1<<endl;
    for(const vector<int> &pa : result){
        for(int i=0; i<pa.size()-1; i++){
            cout<<pa[i]<<" ";
        }
        cout<<pa[pa.size()-1]<<endl;
    }
}
以下这题也是一样的
**797. 所有可能的路径**
```

7.20

```C++
**动态规划14.最后一块石头的重量II**
public:
    int lastStoneWeightII(vector<int>& stones) {
        //尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题
        //石头的重量是 stones[i]，石头的价值也是 stones[i] ，可以 “最多可以装的价值为 dp[j]” == “最多可以背的重量为dp[j]”
        vector<int> dp(15001, 0);
        int sum = accumulate(stones.begin(),stones.end(),0);
        int target = sum / 2;
        for(int i=0; i<stones.size(); i++){
            for(int j=target; j>=stones[i]; j--){
                dp[j] = max(dp[j],dp[j-stones[i]]+stones[i]);//01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
        return sum-dp[target]-dp[target];
    }
```

```c++
**图论5.岛屿数量（深搜）**
本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，然后把该节点陆地所能遍历到的陆地都标记上。
注意点，dir二维数组用于方向的变换。

#include<iostream>
#include<vector>
using namespace std;
//本题思路，是用遇到一个没有遍历过的节点陆地，计数器就加一，
//然后把该节点陆地所能遍历到的陆地都标记上。
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void dfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
    for (int i = 0; i < 4; i++) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
        if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的

            visited[nextx][nexty] = true;
            dfs(grid, visited, nextx, nexty);
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    vector<vector<bool>> visited(n, vector<bool>(m, false));

    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!visited[i][j] && grid[i][j] == 1) {
                visited[i][j] = true;
                result++; // 遇到没访问过的陆地，+1
                dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
            }
        }
    }

    cout << result << endl;
}
```

7.24

```c++
**hot100——3.无重复字符的最长子串**<<滑动窗口>>
1.使用一个哈希表（unordered_map）来存储每个字符及其在字符串中的索引。
2.使用两个指针i和j来表示当前考虑的子串的起始和结束位置。
3.遍历字符串，每次移动j指针，如果发现字符s[j]在哈希表中，则更新i指针的位置到s[j]的下一个位置或当前i的位置（取较大值），这样可以保证窗口内的字符都是不重复的。
4.每次移动j指针后，计算当前窗口的长度，并更新答案。
5.最后返回最长子串的长度。

public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> map; // 存储字符到索引的映射
        int right = 0;
        int maxlen = 0;
        //滑动窗口的左右边界
        for(int left=0, right=0; right<s.size(); right++){
            // 如果字符s[right]在map中，更新i的位置
            if(map.find(s[right]) != map.end()){
                left = max(map[s[right]] + 1, left);
            }
            // 更新答案和字符s[right]的最新位置
            maxlen = max(maxlen, right-left+1);
            map[s[right]] = right;
        }
        return maxlen;
    }
```

```c++
**hot100——438.无重复字符的最长子串**<<滑动窗口>>
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        if(s.size() < p.size()) return result;//直接返回空结果
        vector<int> pcount(26, 0);
        vector<int> scount(26, 0);
        for(int i=0; i<p.size(); i++){
            pcount[p[i]-'a']++;
        }
        for(int left=0, right=0; right<s.size(); right++){
            // 将当前字符加入到窗口计数中
            scount[s[right]-'a']++;
            // 当窗口大小超过p的长度时，需要缩小窗口
            while(right-left+1 > p.size()){
                scount[s[left]-'a']--;
                left++;
            }
             // 如果窗口大小等于p的长度，并且窗口计数与p的计数匹配，则记录起始索引
            if(right-left+1 == p.size() && scount == pcount){
                result.push_back(left);
            }
        }
        return result;
    }
```

7.25

```c++
**图论6.岛屿数量（广搜）**
bfs是用队列来完成对岛屿陆地的遍历，而dfs是用递归来完成的
#include<iostream>
#include<vector>
#include <queue>
using namespace std;

int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void bfs(const vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y){
    queue<pair<int,int>> que;
    que.push({x, y});
    visited[x][y] = true; // 只要加入队列，立刻标记
    while(!que.empty()){
        pair<int, int> cur = que.front();
        que.pop();
        int curx = cur.first;
        int cury = cur.second;
        for(int i=0; i<4; i++){
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if(nextx<0 || nextx>=grid.size() || nexty<0 || nexty>=grid[0].size()) continue;  // 越界了，直接跳过
            if(!visited[nextx][nexty] && grid[nextx][nexty] == 1){
                que.push({nextx, nexty});
                visited[nextx][nexty] = true;// 只要加入队列立刻标记
            }
        }
    }
}
int main(){
    int n, m;
    cin>>n>>m;
    vector<vector<int>> grid(n, vector<int>(m,0));
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            cin>>grid[i][j];
        }
    }
    
    vector<vector<bool>> visited(n, vector<bool>(m, false));
    
    int result = 0;
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(!visited[i][j] && grid[i][j] == 1){
                result++;// 遇到没访问过的陆地，+1
                bfs(grid, visited, i, j);// 将与其链接的陆地都标记上 true
            }
        }
    }
    cout << result << endl;
}
```

```c++
**动态规划17.一和零**
dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]

dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。
dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1。

递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1)
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));// 默认初始化0
        for(string str:strs){// 遍历物品
            int zeronum = 0, onenum = 0;
            for(char c:str){
                if(c == '0') zeronum++;
                else onenum++;
            }
            for(int i=m; i>=zeronum; i--){// 遍历背包容量且从后向前遍历！
                for(int j=n; j>=onenum; j--){
                    dp[i][j] = max(dp[i][j], dp[i-zeronum][j-onenum] + 1);
                }
            }
        }
        return dp[m][n];
    }
```

7.26

```c++
**图论8.孤岛的总面积**
本题要求找到不靠边的陆地面积，那么我们只要从周边找到陆地然后 通过 dfs或者bfs 将周边靠陆地且相邻的陆地都变成海洋，然后再去重新遍历地图 统计此时还剩下的陆地就可以了。
#include<iostream>
#include<vector>

using namespace std;

int dir[4][2] = {1,0,0,1,-1,0,0,-1};
int count;//统计符合题意的陆地空格数量
void dfs(vector<vector<int>>& grid, int x, int y){
    grid[x][y] = 0;
    count++;
    for(int i=0; i<4; i++){
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        // 超过边界
        if(nextx<0 || nextx>=grid.size() || nexty<0 ||nexty>=grid[0].size()) continue;
        if(grid[nextx][nexty] == 0) continue;// 不符合条件，不继续遍历
        
        dfs(grid, nextx, nexty);
    }
    return;
}
int main(){
    int n, m;
    cin >> n >>m;
    vector<vector<int>> grid(n, vector<int>(m,0));
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            cin>>grid[i][j];
        }
    }
    //从左侧边，和右侧边向中间遍历
    for(int i=0; i<n; i++){
        if(grid[i][0] == 1) dfs(grid, i, 0);
        if(grid[i][m-1] == 1) dfs(grid, i, m-1);
    }
    //从上边和下边向中间遍历
    for(int i=0; i<m; i++){
        if(grid[0][i] == 1) dfs(grid, 0, i);
        if(grid[n-1][i] == 1) dfs(grid, n-1, i);
    }
    count = 0;
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            if(grid[i][j] == 1) count++;
        }
    }
    cout<<count<<endl;
}
```

```c++
**hot100——560.和为k的子数组**
	最开始想用回溯，但是由于是要求连续，不适合用。
    为什么想到用前缀和？题目要求子数组，连续非空序列，注意是连续。
    
1.前缀和是指从数组的起始位置到当前元素的和。我们用 current_sum 来表示当前的前缀和。
2.我们需要找到和为 k 的子数组数量。假设当前的前缀和是 current_sum，如果存在一个之前的前缀和 current_sum - k，那么从那个前缀和到当前前缀和之间的子数组的和就是 k。
3.我们使用一个哈希表 prefix_sum_count 来记录每个前缀和出现的次数。这样，我们可以快速判断当前前缀和减去 k 的值是否已经出现过。

    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        int current_sum = 0;
        mp[current_sum] = 1;// 初始前缀和为0出现1次，这一行不可缺少    
        int result = 0;
        for(int i=0; i<nums.size(); i++){
            current_sum += nums[i];
            if(mp.find(current_sum - k) != mp.end()){
                // 如果 current_sum - k 出现在哈希表中，说明存在一个子数组的和为 k
                result += mp[current_sum - k];
            }
            // 将当前前缀和加入哈希表
            mp[current_sum]++;
        }
        return result;
    }
```

7.27

```markdown
**图论9.沉没孤岛**
和前一天做的题相反，思路就是用dfs将1转换为2，再遍历一遍将剩下的1（也就是孤岛）转化为0，将2转化为1。
```

```C++
hot100——76.最小覆盖子串
滑动窗口的思想，一种解法如下：
主要维护：
1.需要匹配的字符种类数量
2.当前s窗口中满足t频率要求的字符数量
3.滑动窗口的左右边界
4.最小窗口的长度及起始位置。
public:
    string minWindow(string s, string t) {
        if(s.empty() || t.empty()){
            return "";
        }
        unordered_map<char,int> mpt,mps;
        for(char c : t){
            mpt[c]++;
        }
        int required = mpt.size(); // 需要匹配的字符种类数量
        int sum = 0; //记录当前窗口中满足 t 频率要求的字符数量
        int left = 0, right = 0;// 滑动窗口的左右边界
        int min_len = INT_MAX, min_left = 0;// 记录最小窗口的长度及起始位置
        while(right < s.size()){
            char c = s[right];
            mps[c]++;
            // 检查当前字符是否满足t中对应字符的频率要求
            if(mpt.find(c) != mpt.end() && mpt[c] == mps[c]){
                sum++;// 满足条件的字符种类数量增加
            }
            // 尝试收缩窗口，直到不再满足条件
            while(left <= right && sum == required){
                if (right - left + 1 < min_len) {
                    min_len = right - left + 1;
                    min_left = left;
                }
                char left_char = s[left];
                mps[left_char]--;// 减少左边界字符在窗口中的频率
                 // 如果左边界字符是t中需要的字符，并且当前频率不足，则减少sum计数
                if(mpt.find(left_char) != mpt.end() && mpt[left_char] > mps[left_char]){
                    sum--;
                }
                left++;//收缩左边界
            }
            right++;//右边界右移
        }
        // 返回最小窗口子串，如果未找到则返回空字符串
        return min_len == INT_MAX ? "" : s.substr(min_left, min_len);
    }
```

7.28

```c++
**hot100——**
初始化两个空数组 L 和 R。对于给定索引 i，L[i] 代表的是 i 左侧所有数字的乘积，R[i] 代表的是 i 右侧所有数字的乘积。
我们需要用两个循环来填充 L 和 R 数组的值。对于数组 L，L[0] 应该是 1，因为第一个元素的左边没有元素。对于其他元素：L[i] = L[i-1] * nums[i-1]。
同理，对于数组 R，R[length-1] 应为 1。length 指的是输入数组的大小。其他元素：R[i] = R[i+1] * nums[i+1]。
当 R 和 L 数组填充完成，我们只需要在输入数组上迭代，且索引 i 处的值为：L[i] * R[i]。

public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int length = nums.size();
        //初始化两个数组，分别计算左往右，右往左的乘积，但是首数字为1
        vector<int> left(length, 1), right(length, 1);
        for(int i=1; i<length; i++){
            left[i] = left[i-1] * nums[i-1];
        }
        for(int i=length-2; i>=0; i--){
            right[i] = right[i+1] * nums[i+1];
        }
        for(int i=0; i<length; i++){
            left[i] = left[i] * right[i];
        }
        return left;
    }
```

```c++
**单调栈1.每日温度**
单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。
本题思路为，维护一个从栈顶到栈底递增的栈。
如果新入栈的元素大于或者等于此时的栈顶元素，则需要循环弹出比新入栈的元素小的元素，再入栈的过程中就可以填充一次answer了。
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> st;//从栈顶到栈底递增
        vector<int> answer(temperatures.size(), 0);
        for(int i=0; i<temperatures.size(); i++){
            while(!st.empty() && temperatures[i] > temperatures[st.top()]){// 注意栈不能为空
                answer[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return answer;
    }
```

7.29

```c++
**单调栈5.柱状图中最大的矩形**
本题和接雨水刚好相反，本题维护的是一个从栈顶到栈底递减的单调栈。
情况一：当前遍历的元素heights[i]大于栈顶元素heights[st.top()]的情况
情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况
情况三：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况

怕走不到情况三的逻辑，所以要在数组头尾加上0。
public:
    int largestRectangleArea(vector<int>& heights) {
        int result = 0;
        stack<int> st;
        heights.insert(heights.begin(), 0); // 数组头部加入元素0
        heights.push_back(0); // 数组尾部加入元素0
        st.push(0);
        // 第一个元素已经入栈，从下标1开始
        for(int i=1; i<heights.size(); i++){
            if(heights[i] > heights[st.top()]){// 情况一
                st.push(i);
            }else if(heights[i] == heights[st.top()]){// 情况二
                st.pop();
                st.push(i);
            }else{// 情况三
                while(!st.empty() && heights[i] < heights[st.top()]){// 注意是while
                    int mid = st.top();
                    st.pop();
                    if(!st.empty()){
                        int left = st.top();
                        int right = i;
                        int w = right - left - 1;
                        int h = heights[mid];
                        result = max(result, w*h); 
                    }
                }
                st.push(i);
            }
        }
        return result;
    }
```

```c++
**单调栈4.接雨水**
之前用双指针也做过，今天用单调栈做。
从栈头（元素从栈头弹出）到栈底的顺序应该是从小到大的顺序。
因为一旦发现添加的柱子高度大于栈头元素了，此时就出现凹槽了，栈头元素就是凹槽底部的柱子，栈头第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子。
情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 height[i] < height[st.top()]
情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 height[i] == height[st.top()]
情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 height[i] > height[st.top()]
public:
    int trap(vector<int>& height) {
        stack<int> st;//用于存储下标
        st.push(0);
        int sum = 0;
        for(int i=1; i<height.size(); i++){
            if(height[i] < height[st.top()]){// 情况一
                st.push(i);
            }else if(height[i] == height[st.top()]){ // 情况二
                st.pop();
                st.push(i);
            }else{// 情况三
                while(!st.empty() && height[i] > height[st.top()]){ // 注意这里是while
                    int mid = st.top();
                    st.pop();
                    if(!st.empty()){
                        int h = min(height[st.top()], height[i]) - height[mid];
                        int w = i - st.top() - 1;
                        sum += h*w;
                    }
                }
                st.push(i);
            }
        }
        return sum;
    }
```

7.30

```c++
**动态规划18.完全背包理论基础**
完全背包和01被背包区别在于，物品可重复选取，所以不需要从后往前遍历（因为之前01背包从后往前就是为了每个物品最多选取一次），而且完全背包的物品和背包容量的遍历可以颠倒。
//完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值
#include <iostream>
#include <vector>
using namespace std;

void CompletePack(vector<int> weight, vector<int> value, int bagWeight){
    vector<int> dp(bagWeight + 1, 0);
    for(int i=0; i<weight.size(); i++){//遍历物品
        for(int j=0; j<=bagWeight; j++){//遍历背包容量，注意这里是小于等于
            if(j >= weight[i]) dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);
        }
    }
    cout<<dp[bagWeight]<<endl;//注意这里是bagWeight而不是weight.size()
}
int main(){
    int N, V;
    cin>>N>>V;
    vector<int> weight, value;
    for(int i=0; i<N; i++){
        int w;
        int v;
        cin>>w>>v;
        weight.push_back(w);
        value.push_back(v);
    }
    CompletePack(weight,value,V);
    return 0;
}
```

```c++
hot100——41.缺失的第一个整数
-本题要求时间复杂度O(N)，空间复杂度O(1)。

如果本题没有额外的时空复杂度要求，那么就很容易实现：
我们可以将数组所有的数放入哈希表，随后从 1 开始依次枚举正整数，并判断其是否在哈希表中；
我们可以从 1 开始依次枚举正整数，并遍历数组，判断其是否在数组中。

如果数组的长度为 N，那么第一种做法的时间复杂度为 O(N)，空间复杂度为 O(N)；第二种做法的时间复杂度为 O(N 
2)，空间复杂度为 O(1)。但它们都不满足时间复杂度为 O(N) 且空间复杂度为 O(1)。

-先复习一下set的用法，也就是时间复杂度O(N)，空间复杂度O(N)的解决方法。
public:
    int firstMissingPositive(vector<int>& nums) {
        std::set<int> s;
        // 将所有正整数加入到集合中
        for (int num : nums) {
            if (num > 0) {
                s.insert(num);
            }
        }
        // 从1开始检查最小的缺失正整数
        int smallest = 1;
        for (int num : s) {
            if (num == smallest) {
                smallest++;
            } else {
                break;
            }
        }
        return smallest;    
    }

解下来是本题的解决方法，要求时间复杂度O(N)，空间复杂度O(1)
1.我们将数组中所有小于等于 0 的数修改为 N+1；（因为对于长度为N的数组，缺失的第一个整数只可能在[1,N+1]）

2.我们遍历数组中的每一个数 x，它可能已经被打了标记，因此原本对应的数为 ∣x∣，其中 ∣∣ 为绝对值符号。如果 ∣x∣∈[1,N]，那么我们给数组中的第 ∣x∣−1 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；

3.在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1，否则答案是第一个正数的位置加 1。
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        for(int& num:nums){
            if(num <= 0) num = n + 1;
        }
        for(int i=0; i<n; i++){
            int num = abs(nums[i]);
            if(num <= n){
                nums[num - 1] = -abs(nums[num-1]);
            }
        }
        for(int i=0; i<n; i++){
            if(nums[i] > 0){
                return i+1;
            }
        }
        return n+1;
    }
```

8.1

```c++
**hot100——543. 二叉树的直径**
public:
    int result;
    int depth(TreeNode* root){
        if(root == nullptr){
            return 0;
        }
        int Left = depth(root->left);
        int Right = depth(root->right);
        result = max(result, Left+Right);
        return max(Left, Right)+1;//返回节点深度
    }
    int diameterOfBinaryTree(TreeNode* root) {
        result = 0;
        depth(root);
        return result;
    }
```

```c++
**动态规划19.零钱兑换II**
本题和纯完全背包不一样，纯完全背包是凑成背包最大价值是多少，而本题是要求凑成总金额的物品组合个数！
	dp[j]：凑成总金额j的货币组合数为dp[j]
纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

而本题要求凑成总和的组合数，元素之间明确要求没有顺序。所以纯完全背包是能凑成总和就行，不用管怎么凑的。
本题是求凑出来的方案个数，且每个方案个数是为组合数。那么本题，两个for循环的先后顺序可就有说法了。
我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。
代码如下：
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
假设：coins[0] = 1，coins[1] = 5。
那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。
所以这种遍历顺序中dp[j]里计算的是组合数！

如果把两个for交换顺序，代码如下：
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。
此时dp[j]里算出来的就是排列数！
    
    
    

以 amount = 5 和 coins = [1, 2, 5] 为例：

初始时：dp = [1, 0, 0, 0, 0, 0]

dp[0] = 1，因为有一种方式凑成金额 0，即不使用任何硬币。
处理硬币 1：

遍历金额从 1 到 5：
dp[1] = dp[1] + dp[0]，所以 dp[1] = 1（用一个硬币 1 凑成 1）
dp[2] = dp[2] + dp[1]，所以 dp[2] = 1（用两个硬币 1 凑成 2）
dp[3] = dp[3] + dp[2]，所以 dp[3] = 1（用三个硬币 1 凑成 3）
dp[4] = dp[4] + dp[3]，所以 dp[4] = 1（用四个硬币 1 凑成 4）
dp[5] = dp[5] + dp[4]，所以 dp[5] = 1（用五个硬币 1 凑成 5）
dp = [1, 1, 1, 1, 1, 1]
处理硬币 2：

遍历金额从 2 到 5：
dp[2] = dp[2] + dp[0]，所以 dp[2] = 2（用一个硬币 2 或两个硬币 1 凑成 2）
dp[3] = dp[3] + dp[1]，所以 dp[3] = 2（用一个硬币 2 和一个硬币 1，或者三个硬币 1 凑成 3）
dp[4] = dp[4] + dp[2]，所以 dp[4] = 3（用两个硬币 2，或者一个硬币 2 和两个硬币 1，或者四个硬币 1 凑成 4）
dp[5] = dp[5] + dp[3]，所以 dp[5] = 3（用一个硬币 2 和三个硬币 1，或者两个硬币 2 和一个硬币 1，或者五个硬币 1 凑成 5）
dp = [1, 1, 2, 2, 3, 3]
处理硬币 5：

遍历金额 5：
dp[5] = dp[5] + dp[0]，所以 dp[5] = 4（用一个硬币 5，或者一个硬币 2 和三个硬币 1，或者两个硬币 2 和一个硬币 1，或者五个硬币 1 凑成 5）
dp = [1, 1, 2, 2, 3, 4]
    
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历硬币
            for (int j = coins[i]; j <= amount; j++) { // 遍历容量
                dp[j] = dp[j] + dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
```

8.2

```markdown
**图论10.水流问题**

```

```c++
**hot100——73.矩阵置零**
本题是将一个二维矩阵中的所有0所在的行和列都置为0。
如果对空间复杂度不做要求，那么可以使用一个行数组和一个列数组来记录需要置零的行和列只需要遍历一遍数组，在赋值一遍数组。
但如果要求O(1)的空间复杂度，那么就可以用这个矩阵的第一行和第一列来充当这个行数组和列数组，所以还需要额外的遍历和变量来记录第一行第一列本身是否含有0。
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(); // 获取矩阵的行数
        int n = matrix[0].size(); // 获取矩阵的列数

        bool rowfirst = false, colfirst = false; // 用来记录第一行和第一列是否需要置为0
        // 检查第一行是否有0
        for(int i = 0; i < n; i++) {
            if(matrix[0][i] == 0) {
                rowfirst = true; // 如果有0，标记rowfirst为true
                break;
            }
        }
        // 检查第一列是否有0
        for(int i = 0; i < m; i++) {
            if(matrix[i][0] == 0) {
                colfirst = true; // 如果有0，标记colfirst为true
                break;
            }
        }
        // 使用第一行和第一列作为标记，如果某个位置(matrix[i][j])为0，
        // 那么将对应的第一行和第一列的位置(matrix[i][0], matrix[0][j])标记为0
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++) {
                if(matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }
        // 再次遍历矩阵，如果第一行或第一列的某个标记为0，
        // 那么将该行或该列的所有元素置为0
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++) {
                if(matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        // 如果第一行需要置为0，那么将第一行的所有元素置为0
        if(rowfirst) {
            for(int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
        // 如果第一列需要置为0，那么将第一列的所有元素置为0
        if(colfirst) {
            for(int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
```





